#' Get Population Denominators for CHI Analysis
#'
#' @description
#' Retrieves population estimates based on instructions generated by
#' \code{\link{chi_generate_instructions_pop}}. This function processes demographic
#' categories, geographic levels, and time periods to create appropriate
#' population denominators for use in CHI rate calculations.
#'
#' @param pop.template A data.table produced by \code{\link{chi_generate_instructions_pop}},
#' containing instructions for population data retrieval with the following columns:
#'  \itemize{
#'    \item \code{year}: Year range (e.g., "2019-2021" or single year)
#'    \item \code{cat1}, \code{cat1_varname}: Primary stratification variables
#'    \item \code{cat2}, \code{cat2_varname}: Secondary stratification variables
#'    \item \code{tab}: Visualization tab type
#'    \item \code{start}, \code{stop}: Start and end years parsed from the year range
#'    \item \code{race_type}: Race categorization type ('race', 'race_eth', or 'race_aic')
#'    \item \code{geo_type}: Geographic level for analysis ('kc', 'hra', 'region', 'blk', 'zip', 'wa')
#'    \item \code{group_by1}, group_by2: Race/eth grouping specifications ('race_eth', 'race')
#'  }
#' @param pop.genders Optional character vector specifying which genders to include.
#' Valid values are \code{'f'}, \code{'female'}, \code{'m'}, \code{'male'}. If NULL (default), both genders are included.
#' @param pop.ages Optional integer vector specifying which ages to include.
#' If \code{NULL} (default), ages 0-100 are included.
#' @param is_chars Logical (T|F). If \code{TRUE}, will calculate King County population based
#' on ZIP codes beginning with 980 or 981, which is necessary for CHARS data.
#' Default \code{is_chars = FALSE}.
#'
#' @return Returns a data.table containing population counts with columns:
#'  \itemize{
#'    \item \code{chi_age}: Single year age
#'    \item \code{year}: Year
#'    \item \code{cat1}, cat1_varname, cat1_group: Primary stratification variables
#'    \item \code{cat2}, cat2_varname, cat2_group: Secondary stratification variables
#'    \item \code{tab}: Visualization tab type
#'    \item \code{pop}: Population count
#'  }
#'
#' @details
#' The function:
#' \enumerate{
#'    \item Validates inputs
#'    \item Batches similar population queries based on key parameters
#'    \item Makes minimal database calls to cover all required year ranges
#'    \item Post-processes data in R to match the original template requirements
#'    \item When \code{is_chars=TRUE}, uses a different approach for King County that aggregates
#'    populations from ZIP codes starting with 980/981 instead of using the standard
#'    King County boundary
#' }
#'
#'
#' For better performance, we recommended using futures for parallel processing. Here is one suggested set up:
#'
#' \preformatted{
#' library(future)
#'
#' options(future.globals.maxSize = 3000 * 1024^2)  # this sets a 3GB limit per future
#'
#' num.cores <- future::availableCores() - 1 # use one less than the available cores
#'
#' plan(multisession(workers = num.cores[1])) # set up a multisession plan
#' }
#'
#' @seealso
#' \code{\link{chi_generate_instructions_pop}} which generates the instructions used as input
#' for this function
#'
#' @importFrom data.table alloc.col copy rbindlist set setkey uniqueN `:=`
#' @importFrom qs qread qsave
#' @importFrom future plan
#' @importFrom future.apply future_lapply
#' @importFrom tools toTitleCase
#' @importFrom progressr handlers progressor with_progress handler_progress
#' @export
#'
chi_get_proper_pop <- function(pop.template = NULL,
                                 pop.genders = NULL,
                                 pop.ages = NULL,
                                 is_chars = FALSE) {
  # STEP 1: Validate and prepare inputs ----
  validated <- validate_inputs(pop.template, pop.genders, pop.ages, is_chars)
  pop.template <- validated$pop.template
  gender_values <- validated$gender_values
  age_values <- validated$age_values

  # STEP 2: Batch similar queries ----
  pop.template <- standardize_category_names(pop.template)
  pop.template <- create_query_keys(pop.template)
  batched <- batch_population_queries(pop.template)
  pop.template <- batched$pop.template
  batched_queries <- batched$batched_queries

  # STEP 3: Get population data for batched queries ----
  message("\U023F3 Pulling ", nrow(batched_queries), " population tables from SQL ... be patient!",
          "\n Key: cat1||cat1_varname||cat2||cat2_varname||race_type||geo_type||group_by1||group_by2")

    # If futures are NOT used: run sequentially ----
      if (inherits(future::plan(), "sequential")) {
        message("Processing queries sequentially...")
        all_population_data <- data.table::rbindlist(
          lapply(
            X = batched_queries$batched_id,
            FUN = function(query_id) {
              message(paste0("Processing ", query_id, " of ",
                             data.table::uniqueN(batched_queries$batched_id), ": ",
                             batched_queries[batched_id == query_id]$query_key))
              get_batched_population(query_id,
                                     pop.template,
                                     batched_queries,
                                     gender_values,
                                     age_values,
                                     is_chars)
            }
          ),
          fill = TRUE
        )
      }

    # If futures ARE used: run in parallel ----
    if (!inherits(future::plan(), "sequential")) {
      progressr::handlers(progressr::handler_progress())
      progressr::with_progress({
        p <- progressr::progressor(nrow(batched_queries))
        all_population_data <- data.table::rbindlist(
          future.apply::future_lapply(
            X = batched_queries$batched_id,
            FUN = function(query_id) {
              p(paste0("Processing ", query_id, " of ",
                       data.table::uniqueN(batched_queries$batched_id), ": ",
                       batched_queries[batched_id == query_id]$query_key ))
              get_batched_population(query_id,
                                     pop.template,
                                     batched_queries,
                                     gender_values,
                                     age_values,
                                     is_chars)
            },
            future.seed = 98104 # Set seed for parallel processes
          )
          , fill = TRUE)
      })
    }

  # STEP 4: Process each template row ----
  message("\U023F3 Allocating the population data for each row in pop.template. Be patient!")

  # Convert years to to integers for comparisons
  data.table::set(all_population_data, j = "year", value = as.integer(all_population_data[["year"]]))
  if(is.character(pop.template$start)) pop.template[, start := as.integer(start)]
  if(is.character(pop.template$stop)) pop.template[, stop := as.integer(stop)]

    # If futures are NOT used: run sequentially ----
    if (inherits(future::plan(), "sequential")) {
      message("Processing rows sequentially...")
      final_population_data <- data.table::rbindlist(
        lapply(
          X = seq_len(nrow(pop.template)),
          FUN = function(row_index) {
            message(paste0("Processing row ", row_index, " of ", nrow(pop.template)))

            # Extract data for this row directly
            current_row <- pop.template[row_index, ]
            filtered_population <- all_population_data[
              batched_id == current_row$batched_id &
                year >= current_row$start &
                year <= current_row$stop
            ]

            # Process without temp files
            process_template_row(row_index, filtered_population, pop.template, age_values)
          }
        )
      )
    }

    # If futures ARE used: run in parallel ----
    if (!inherits(future::plan(), "sequential")) {
      # Allocate some extra column slots to prevent data.table errors during non-equi joins
      invisible(data.table::alloc.col(all_population_data, 5))
      invisible(data.table::alloc.col(pop.template, 5))

      # Add row index to pop.template for identifying which rows to process
      pop.template[, row_index := .I]

      # Use a non-equi join to match all_population_data rows with pop.template rows
      # based on batched_id and proper year range
      population_subsets <- all_population_data[
        pop.template[, list(batched_id, start, stop, row_index)],
        on = list(batched_id == batched_id, year >= start, year <= stop),
        nomatch = 0  # Drop rows that don't match
      ]

      # Remove any year columns from the population data (was only needed for the join)
      population_subsets[, grep('year', names(population_subsets), value = T) := NULL]

      # Create temporary directory to store filtered data files
      # This allows each future worker to load only what it needs -
      # avoids the persistent memory issues of sending all the pop data to each future
      temp_dir <- file.path(tempdir(), "filtered_data")
      dir.create(temp_dir, showWarnings = FALSE, recursive = TRUE)

      # Save each subset of data as a separate file in the temporary directory
      message("\U023F3 Saving filtered population data to temporary files...")
      for(i in unique(pop.template$row_index)) {
        # Extract and save just the data needed for this template row

        qs::qsave(population_subsets[row_index == i], # faster alternative to saveRDS
                  file = file.path(temp_dir, paste0("row_", i, ".qs")),
                  preset = "fast")

        if(i %% 5 == 0) {message('Saved ', i, ' of ', max(pop.template$row_index), ' population tables')}
      }

      # Free up memory by removing the population data that is no longer needed
      rm(list = c('population_subsets', 'all_population_data'))
      gc()

      # Process each row of pop.template in parallel
      message("\U023F3 Producing a combined population table with standard CHI columns")
      progressr::handlers(progressr::handler_progress())
      progressr::with_progress({
        p <- progressr::progressor(nrow(pop.template))

        final_population_data <- data.table::rbindlist(
          future.apply::future_lapply(
            X = seq_len(nrow(pop.template)),
            FUN = function(row_index) {
              # Update progress
              p(paste0("Post-processing row ", row_index, " of ", nrow(pop.template)))

              # Load only the data needed for this specific row (faster than readRDS)
              filtered_population <- qs::qread(file.path(temp_dir, paste0("row_", row_index, ".qs")))

              # Process the data using the template row
              result <- process_template_row(
                row_index = row_index,
                population_data = filtered_population,
                pop.template = pop.template,
                age_values = age_values)

              return(result)
            },
            future.seed = 98104  # Ensure reproducible results across parallel processes
          )
        )
      })

      # Clean up temporary files
      message("Cleaning up temporary files...")
      unlink(temp_dir, recursive = TRUE)
    }

  # STEP 5: Finalize and return result ----
  # Remove duplicate rows in final dataset
  final_population_data <- unique(final_population_data)

  # Return final population dataset
  return(final_population_data)
}
